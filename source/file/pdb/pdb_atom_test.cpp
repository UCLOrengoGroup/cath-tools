/// \file


/// \copyright
/// CATH Tools - Protein structure comparison tools such as SSAP and SNAP
/// Copyright (C) 2011, Orengo Group, University College London
///
/// This program is free software: you can redistribute it and/or modify
/// it under the terms of the GNU General Public License as published by
/// the Free Software Foundation, either version 3 of the License, or
/// (at your option) any later version.
///
/// This program is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
///
/// You should have received a copy of the GNU General Public License
/// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <boost/test/auto_unit_test.hpp>

#include "common/boost_addenda/test/boost_check_no_throw_diag.hpp"
#include "exception/invalid_argument_exception.hpp"
#include "file/pdb/pdb_atom.hpp"

#include <iostream>

using namespace cath;
using namespace cath::common;
using namespace cath::file;
using namespace std;

namespace cath {
	namespace test {

		/// \brief The pdb_atom_test_suite_fixture to assist in testing pdb_atom
		struct pdb_atom_test_suite_fixture {
		protected:
			~pdb_atom_test_suite_fixture() noexcept = default;

			const string ATOM_RECORD_SIMPLE           = { "ATOM      1  N   LEU A 999       0.041 148.800  54.967  1.00 35.61           N  " };
			const string ATOM_RECORD_SHORT            = { "ATOM      1  N   LEU A 999       0.041 148.800  54.967  1.00 35.61           N"   };
			const string ATOM_RECORD_DNA              = { "ATOM     60  P    DT B 405     -34.489  40.044 103.442  1.00 22.35           P  " };
			const string ATOM_RECORD_NEG_RES_NUM      = { "ATOM   2041  N   ASN B  -1     -27.445  -1.104  16.047  1.00 65.16           N  " };
			const string ATOM_RECORD_RALIGNED_RES_NUM = { "ATOM     89  N   GLU   200     -60.412  54.016  32.157  1.00  0.00           N  " };
			const string ATOM_RECORD_LALIGNED_RES_NUM = { "ATOM    182  N   GLU  200       -0.292   3.837   4.911  1.00226.06           N  " };
			const string ATOM_RECORD_HAS_CHARGE       = { "HETATM 2959 ZN    ZN A1392      19.359  67.577 -13.048  1.00 34.67          ZN2+" };

			/// \brief Return the PDB line string generated by parsing the specified PDB line string
			///        and then writing the results back to a PDB line string
			string parse_and_write_pdb_line(const string &arg_pdb_line ///< The PDB line to parse into objects that should then be written out again to a PDB line
			                                ) {
				const resid_atom_pair parsed_details = parse_pdb_atom_record( arg_pdb_line );
				return to_pdb_file_entry(
					parsed_details.first,
					parsed_details.second
				);
			}

		};

	}
}

BOOST_FIXTURE_TEST_SUITE(pdb_atom_test_suite, cath::test::pdb_atom_test_suite_fixture)


BOOST_AUTO_TEST_CASE(parse_from_simple_line) {
	const pdb_atom &my_atom = parse_pdb_atom_record( ATOM_RECORD_SIMPLE ).second;

	BOOST_CHECK_EQUAL(   0.041, my_atom.get_coord().get_x() );
	BOOST_CHECK_EQUAL( 148.800, my_atom.get_coord().get_y() );
	BOOST_CHECK_EQUAL(  54.967, my_atom.get_coord().get_z() );
}



BOOST_AUTO_TEST_SUITE(parsing_and_writing_recreates_orig)

BOOST_AUTO_TEST_CASE(parsing_and_writing_simple_recreates_orig) {
	BOOST_CHECK_EQUAL( parse_and_write_pdb_line( ATOM_RECORD_SIMPLE           ), ATOM_RECORD_SIMPLE           );
}

BOOST_AUTO_TEST_CASE(parsing_and_writing_short_recreates_orig) {
	BOOST_CHECK_EQUAL( parse_and_write_pdb_line( ATOM_RECORD_SHORT            ), ATOM_RECORD_SHORT            );
}

BOOST_AUTO_TEST_CASE(parsing_and_writing_with_space_in_aa_recreates_orig) {
	BOOST_CHECK_EQUAL( parse_and_write_pdb_line( ATOM_RECORD_DNA              ), ATOM_RECORD_DNA              );
}

BOOST_AUTO_TEST_CASE(parsing_and_writing_neg_res_num_recreates_orig) {
	BOOST_CHECK_EQUAL( parse_and_write_pdb_line( ATOM_RECORD_NEG_RES_NUM      ), ATOM_RECORD_NEG_RES_NUM      );
}

BOOST_AUTO_TEST_CASE(parsing_and_writing_pdb_line_recreates_orig) {
	BOOST_CHECK_EQUAL( parse_and_write_pdb_line( ATOM_RECORD_RALIGNED_RES_NUM ), ATOM_RECORD_RALIGNED_RES_NUM );
}

BOOST_AUTO_TEST_CASE(parsing_and_writing_with_charge_recreates_orig) {
	BOOST_CHECK_EQUAL( parse_and_write_pdb_line( ATOM_RECORD_HAS_CHARGE       ), ATOM_RECORD_HAS_CHARGE       );
}

BOOST_AUTO_TEST_SUITE_END()



/// \brief Check that ATOM parsing doesn't permit a right aligned residue number if that's specified
BOOST_AUTO_TEST_CASE(requiring_right_aligned_res_num_throws_if_not_right_aligned) {
	BOOST_CHECK_NO_THROW_DIAG( parse_pdb_atom_record( ATOM_RECORD_RALIGNED_RES_NUM )                             );
	BOOST_CHECK_THROW(         parse_pdb_atom_record( ATOM_RECORD_LALIGNED_RES_NUM ), invalid_argument_exception );
}


BOOST_AUTO_TEST_SUITE_END()

